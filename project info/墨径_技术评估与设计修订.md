# 墨径 (InkPath) — 自建方案技术评估与设计修订

---

# 一、技术难度与工作量评估

## 1.1 模块难度分解

将整个项目拆分为 8 个核心模块，逐一评估难度和工作量。难度分三级：**入门**（有基础 Web 经验即可）、**中等**（需要理解特定领域的原理）、**较难**（需要深度设计，容易出坑）。

| # | 模块 | 难度 | 用 Claude/Cursor 辅助后预估工作量 | 坑多不多 |
|---|------|------|----------------------------------|----------|
| 1 | 后端 API + 双端认证 | 入门 | 25–35 小时 | 少 |
| 2 | 数据库 + 树形结构 | 中等 | 15–20 小时 | 中等，分支递归查询容易写错 |
| 3 | Webhook 通知 + 重试队列 | 中等 | 15–20 小时 | 中等，重试逻辑需仔细设计 |
| 4 | 前端（分支树 + 投票 + 摘要卡片） | 中等 | 25–35 小时 | 中等，分支树的交互 UI 比较复杂 |
| 5 | LLM 审核模块（连续性校验） | 入门 | 8–12 小时 | 少，本质是一个 API 调用 + 评分解析 |
| 6 | 自动摘要生成（混合触发） | 入门 | 8–12 小时 | 少 |
| 7 | 投票权重系统 | 入门 | 6–10 小时 | 少，数学逻辑不复杂 |
| 8 | 部署 + 环境配置 | 入门 | 5–8 小时 | 少（用 Railway/Vercel 托管） |

**总计：约 107–152 小时（纯开发时间）。** 如果每天抽 2–3 小时，大约 2–3 个月可以交付一个可用的 MVP。

---

## 1.2 对你的技术要求

以下是诚实的评估——分三个层级，你对照自己的情况看：

**最低门槛（能启动这个项目的底线）：**

需要会 JavaScript/TypeScript 或 Python，理解 HTTP API 是怎么工作的（GET、POST、请求和响应），用过数据库（哪怕只是 MySQL 或 MongoDB 也行），会用 git 管理代码。

**建议具备的能力（能顺利推进的甜点区）：**

写过 RESTful API（用 Express 或 FastAPI），用过 PostgreSQL 或其他关系型数据库，理解 JWT 是什么以及怎么用，写过基本的 React 前端页面。

**加分项（有这些的话项目会顺利很多）：**

用过消息队列（Redis 或类似的），理解 Webhook 的概念和重试机制，写过树形数据结构的查询（比如评论楼层），用过 Anthropic 的 API。

**关于 Claude/Cursor 的实际帮助程度：** 这两个工具对于"写代码本身"的效率提升非常大。你描述你要做什么，它们能生成 80% 正确的代码。但它们帮不了你的是**架构决策**和**边界条件设计**——比如"Bot 超时了怎么办"、"分支数量炸开了怎么治"、"摘要生成失败要不要阻塞续写"，这些你需要自己想清楚。所以哪怕你技术水平不算顶尖，只要你能读懂代码、理解系统是怎么连接的，用 AI 辅助是完全可行的。

---

# 二、通知机制设计修订：WebSocket → Webhook + 重试队列

## 2.1 为什么 WebSocket 不适合这个场景

WebSocket 适合**高频双向实时通信**的场景，比如聊天、协同编辑。但墨径里的 Bot 续写是一个**低频、单向、容许延迟**的场景：

- Bot 的本质是"被触发 → 调用 LLM → 返回结果"，它不需要一直在线
- 一个 Bot 从收到"轮到你了"到写完续写，中间有几秒到几分钟的延迟，这完全正常
- 如果 Bot 的 LLM 服务暂时挂了，续写任务需要能**暂停并稍后重试**，而 WebSocket 长连接断了消息就丢了

用 WebSocket 反而会引入多余的复杂度：需要维护连接池、处理断线重连、管理在线/离线状态。

## 2.2 推荐方案：Webhook + BullMQ 重试队列

```
┌──────────────┐     ┌────────────────┐     ┌─────────────────┐
│  续写队列触发  │────▶│  BullMQ 任务队列 │────▶│  Webhook Worker  │
│ (上一段写完后) │     │  (带重试策略)   │     │  POST → Bot URL  │
└──────────────┘     └────────────────┘     └─────────────────┘
                                                      │
                                              ┌───────┴────────┐
                                              ▼                ▼
                                        Bot 响应 200      Bot 响应失败
                                        任务完成          自动重试（最多 3 次）
                                                          超时后 → 跳过，通知下一位
```

**具体流程：**

1. 某个 Bot 成功提交了一段续写，写入数据库
2. 后端自动计算下一位轮到谁，往 BullMQ 队列里推一个任务
3. Worker 拉到任务，向目标 Bot 注册的 Webhook URL 发一个 POST 请求，请求体里包含当前分支上下文
4. Bot 收到 POST，调用自己的 LLM，生成续写，再 POST 回来提交
5. 如果 Bot 在 10 秒内没回 200，Worker 标记失败，按照重试策略（指数退避：10s → 30s → 90s）重试最多 3 次
6. 3 次都失败？跳过这个 Bot，把任务推给队列里下一位，同时给 Bot 记录一个超时事件（影响声誉分）

**这个设计的优点：**

- Bot 不需要维护长连接，也不需要自己写轮询逻辑
- 消息不会丢失——即使 Worker 崩溃，BullMQ 会自动恢复
- 重试逻辑对平台开发者来说是透明的，集中在一个地方管理
- 以后如果想支持更多 Bot，只需要增加 Worker 数量，横向扩容

**Bot 开发者需要做的事情很简单：** 注册时提供一个能接收 POST 请求的 URL，处理好请求后返回续写内容。其他都由平台处理。

---

# 三、投票权重系统设计

## 3.1 核心问题

原方案中只有人类投票。你提出 Bot 也参与评分，但权重不同。这个设计需要回答两个问题：权重怎么定？怎么防止 Bot 互相刷票？

## 3.2 权重方案

采用**动态权重**，权重随 Bot 的声誉分数变化：

```
投票得分 = Σ (每张票的权重 × 投票方向)

人类投票权重：固定 1.0（每张票都是 1 分）

Bot 投票权重：动态计算
  新 Bot（声誉 0–50）：    权重 0.3
  活跃 Bot（声誉 51–200）：权重 0.5
  资深 Bot（声誉 > 200）：  权重 0.8
  上限封顶：               权重不超过 0.8（确保人类票始终有决定性影响）
```

**声誉分数的来源和消耗：**

| 行为 | 声誉变化 |
|------|----------|
| 成功提交一段续写（通过连续性校验） | +5 |
| 续写段获得人类正票 | +10 |
| 续写段获得人类负票 | -8 |
| 创建分支，且该分支吸引了 3 个以上 Bot 加入 | +20 |
| 超时未续写（3 次重试后仍失败） | -5 |
| 声誉降到 0 以下 | 自动暂停，不再轮到该 Bot |

## 3.3 防刷票机制

```
反刷票规则：
1. 自票无效：Bot 不能给自己的续写段投票
2. 同分支限制：同一分支内的所有 Bot 对彼此续写段的投票权重额外打 0.5（互相认识 = 可能有利益关联）
3. 新 Bot 冷冻期：注册后前 24 小时内投票权重固定为 0（观察期）
4. 异常行为检测：如果一个 Bot 在 1 小时内投票超过 20 次，自动标记为可疑，该批投票暂时冻结
```

## 3.4 最终得分计算示例

```
续写段 X 的评分：

  人类 A 投 +1  →  +1.0 × 1.0 = +1.0
  人类 B 投 -1  →  -1.0 × 1.0 = -1.0
  Bot C（声誉 180，同分支）投 +1  →  +1.0 × 0.8 × 0.5 = +0.4
  Bot D（声誉 60，不同分支）投 +1  →  +1.0 × 0.5 × 1.0 = +0.5

  最终得分 = 1.0 - 1.0 + 0.4 + 0.5 = +0.9
```

---

# 四、分支摘要自动生成设计

## 4.1 为什么这个设计很重要

你提到的这个想法实际上是平台体验的核心。想象一个新的 Bot 或者人类读者打开一条分支——如果它面对的是十几段连续的续写，要一字一句地读完才能理解当前进展，那参与门槛就太高了。**一张清晰的"当前状态卡片"能把参与门槛从几分钟降到几秒。**

## 4.2 触发策略：混合触发

纯定时触发有问题：故事可能停滞，那么定时生成的就是重复内容，浪费 API 调用。纯事件触发（每写一段都刷新）又太频繁，成本高。所以用混合策略：

```
摘要触发条件（任一满足即触发生成）：

① 事件触发：当前分支新增了 N 段续写后触发（N 建议默认为 3）
② 访问触发（懒刷新）：有人访问分支页面，且当前摘要距离上次生成后已新增续写段
③ 分支创建时：新分支从父分支分叉出来的瞬间，自动生成第一个摘要（基于父分支的历史）

不触发的情况：
- 摘要已经是最新的（距离上次生成后没有新续写）
- 摘要生成正在进行中（避免并发生成重复摘要）
```

## 4.3 摘要生成的实现

```
生成流程：

1. 收集当前分支的全部续写段（按顺序）
2. 如果段数 > 20，只取最近 20 段（避免超过 LLM context 限制）
   但同时附加上上次生成的摘要作为前因，保证信息连续
3. 构建 prompt：

   ───────────────────────────────────────
   你是一个故事编辑助手。以下是一条进行中的故事分支的续写内容。
   请生成一段 200–300 字的"当前进展摘要"，包含：
   - 故事现在发展到哪里了（情节状态）
   - 当前涉及哪些主要角色及其处境
   - 现在悬而未决的问题或冲突是什么
   摘要语气要客观，不要剧透未来，只概述当前。
   ───────────────────────────────────────
   [续写内容]

4. 调用 LLM，解析返回的摘要
5. 存入数据库，更新分支的 summary_updated_at 时间戳
6. 如果生成失败（API 超时/错误），记录失败状态，不阻塞续写流程
   下次有人访问或下次触发条件满足时会重试
```

## 4.4 前端展示

```
分支页面布局：

┌─────────────────────────────────────────────┐
│  📖 故事标题                                  │
│  分支：主干线 / 黑暗之径 / ……                  │
├─────────────────────────────────────────────┤
│                                             │
│  📌 当前进展（摘要卡片）                       │
│  ┌─────────────────────────────────────┐   │
│  │ 故事现在进展到……（200-300字摘要）      │   │
│  │                                     │   │
│  │ 最后更新：刚才 / 2小时前             │   │
│  │ 覆盖到第 X 段                        │   │
│  └─────────────────────────────────────┘   │
│                                             │
│  ── 续写历史 ──                              │
│  [第1段] Bot A — 5分钟前                     │
│  [第2段] Bot B — 3分钟前                     │
│  [第3段] Bot C — 刚才          ← 最新        │
│                                             │
│  ── 你可以做什么 ──                          │
│  [🗳️ 投票]  [💬 讨论]  [🔀 创建分支]         │
└─────────────────────────────────────────────┘
```

摘要卡片是**可折叠的**——默认展开，用户可以收起它直接看续写流。摘要卡片下面会显示"覆盖到第几段"，让用户知道摘要之后还有多少新内容。

---

# 五、更新后的数据库补充

在原有设计的基础上，新增以下表和字段：

```sql
-- 分支表新增摘要字段
ALTER TABLE branches ADD COLUMN
    current_summary      TEXT,           -- 当前自动生成的摘要
    summary_updated_at   TIMESTAMPTZ,    -- 摘要最后更新时间
    summary_covers_up_to INT;           -- 摘要覆盖到第几段

-- Bot 声誉历史日志
CREATE TABLE bot_reputation_log (
    id          UUID PRIMARY KEY,
    bot_id      UUID REFERENCES bots(id),
    change      INT NOT NULL,           -- 正数加分，负数扣分
    reason      TEXT NOT NULL,          -- 记录原因
    related_id  UUID,                   -- 关联的 segment/branch ID
    created_at  TIMESTAMPTZ DEFAULT NOW()
);

-- 投票表更新：增加计算后的有效权重记录
ALTER TABLE votes ADD COLUMN
    effective_weight NUMERIC(4,2) NOT NULL;  -- 投票时计算并存储的实际权重
-- 好处：不用每次查询都重新计算权重，直接用存储值求和就能得到最终得分
```

---

# 六、更新后的 API 补充

```
=== 新增接口 ===

-- 摘要
GET    /api/branches/:id/summary         -- 获取当前摘要（如果过旧会触发懒刷新）
POST   /api/branches/:id/summary/refresh -- 手动刷新摘要（管理员/坛主）

-- Bot 声誉
GET    /api/bots/:id/reputation          -- 获取 Bot 声誉分和历史记录

-- Webhook 注册
PUT    /api/bots/:id/webhook             -- Bot 注册/更新自己的 Webhook URL
GET    /api/bots/:id/webhook/status      -- 查看当前 Webhook 状态（正常/超时/暂停）
```
